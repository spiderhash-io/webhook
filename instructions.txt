Security testing:
Take 1 existing feature, research code and code methods used in it, 
Research internet what attacks these methods could brake or be hacked with
only reseach fixes for external threats through http
double check if this is already tested in existing tests
make extensive test to find gaps in this feature
make tests, if they fail fix them.





You are an expert security engineer performing a targeted security audit on one existing feature in this codebase.

Follow this exact workflow for ONE feature only (pick the most critical or complex one if multiple exist, e.g. user authentication, file upload, file upload, payment processing, etc.):

1. **Feature Selection & Code Analysis**
   - Identify and clearly state which single feature you are auditing.
   - Locate all relevant source code files, classes, functions, and endpoints related to this feature.
   - Summarize the architecture and key methods/technologies used (e.g., JWT auth, OAuth2, file parsing with Sharp or Pillow, raw SQL queries, deserialization of user input, etc.).

2. **Threat Research (External HTTP-based Attacks Only)**
   - For each key method/technology identified, research the most common and critical web vulnerabilities associated with it in 2024–2025 (focus only on attacks that can be triggered via HTTP requests from an external attacker).
   - Prioritize OWASP Top 10 and recent CVEs. Common examples:
     - Authentication/Authorization: IDOR, JWT weaknesses, session fixation, broken auth
     - Input handling: SSRF, SSTI, command injection, XXE, deserialization attacks
     - File uploads: path traversal, unrestricted file type, image library vulnerabilities
     - APIs: mass assignment, GraphQL introspection, excessive data exposure
   - List the specific vulnerabilities that realistically apply to the code you analyzed.

3. **Existing Test Coverage Check**
   - Search the entire test suite for existing security tests related to this feature.
   - Explicitly check for tests covering each vulnerability you listed in step 2.
   - Report which vulnerabilities are already covered and which are completely missing or only partially tested.

4. **Create Comprehensive Security Tests**
   - Write new, realistic, end-to-end or integration tests (using the existing testing framework — Jest, PyTest, Go testing, etc.) that attempt to exploit every missing or under-tested vulnerability.
   - Tests must:
     - Simulate real malicious HTTP requests (use supertest, http.Client, curl examples, or equivalent)
     - Include both positive (should be blocked) and negative controls
     - Cover edge cases, large payloads, encoded inputs, rate-limit bypass attempts, etc.
   - Make the tests fail intentionally if the vulnerability still exists.

5. **Fix Failing Tests (if any)**
   - If any of the new tests fail (i.e., the vulnerability is exploitable):
   - Propose the minimal, secure code fix following current best practices.
   - Implement the fix directly in the relevant files.
   - Re-run the tests and confirm they now pass.
   - Add clear comments explaining the vulnerability and the mitigation.

6. **Final Report (at the end)**
   Output a concise security report with:
   - Feature audited
   - Vulnerabilities researched
   - Coverage gaps found
   - New tests added (count)
   - Fixes applied (with diff summaries)
   - Final risk assessment (Critical/High/Medium/Low/none)

Start now. Do not ask for confirmation — pick the most important feature and begin step 1 immediately.




webhook.site (https://github.com/webhooksite/webhook.site) ok
webhookd (adnanh/webhookd)              ok
smee-client (probot/smee-client)
ngrok (inconshreveable/ngrok)



look at the project ngrok (inconshreveable/ngrok)
and look what thinfs they are testing in their unittets, compare that to our already tested thngs and give 1-2 sentence, poer item,  todo list of what must be tested
do only http req tets